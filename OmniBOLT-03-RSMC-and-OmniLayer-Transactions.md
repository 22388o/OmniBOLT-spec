# OmniBOLT #3: RSMC and OmniLayer Transactions

Sometimes we use "money" instead of Omni assets for illustration purpose. Readers just image that what we fund, transfer or trade is USDT, an important asset issued on Omnilayer.

From this chapter on, our context is Omnilayer, not only bitcoin any more.

## The `funding_created` and `funding_signed` Message 

The two messages describe the outpoint which the funder has created for the initial commitment transactions. After receiving the peer's signature, via `funding_signed`, it will broadcast the funding transaction to the BTC/Omnilayer network.

We focus on omni assets in founding creation. Here are two proposals:

**Prop 1**. Alice and Bob create a 2-2 P2SH payment to `scriptPubKey`, which is the hash of the **Redeem Script**.

**Prop 2**. Alice, Bob and Satoshi create a 2-3 P2SH payment to `scriptPubKey`, where Satoshi takes the responsibility to check/verify all the transactions within the channel. The advantage of this proposal is that when Alice wants to withdraw money from the channel, she does not need the signature from Bob, the only thing she has to do is provide her signature and notify Satoshi to check the channel ledger, and if the money belongs to Alice, Satoshi will provide his signature so that Alice get her money on Omnilayer network.

Proposal 2 has possible vulnerability under the **conspiracy attack**. We will address this issue in the following chapters.

```
    +-------+                              +-------+
    |       |--(1)---  open_channel  ----->|       |
    |       |<-(2)--  accept_channel  -----|       |
    |       |                              |       |
    |   A   |--(3)--  funding_created  --->|   B   |
    |       |<-(4)--  funding_signed  -----|       |
    |       |                              |       |
    |       |         channel_A_B          |       | 
    | to do |(4.1)-->deposit_X_USDT        |       |
    |       |        deposit_Y_USDT <-(4.2)|       |
    |       |                              |       |
    |       |                              |       |
    |       |                              |       |
    |       |--(5)--- funding_locked  ---->|       |
    |       |<-(6)--- funding_locked  -----|       |
    +-------+                              +-------+

    - where node Alice is 'funder' and node Bob is 'fundee'. Same to BOLT, the fundee does not allowed to fund the channel. 
    This is because the limitation of current BTC implementation. 
    Of course, each of them can withdraw money if the counterparty agrees, as long as the two parties sign the correct Revocable Sequence Maturity Contracts for these onchain transactions.  

```

**Proposal 1: 2-2 P2SH**:
 
In order to avoid malicious counterparty who rejects to sign any payment out of the P2SH transaction, so that the money is forever locked in the channel, we construct a Commitment Transaction where one is able to revoke a transaction. This is the first place we introduce the Revocable Sequence Maturity Contract (RSMC), invented by Poon and Dryja in their white paper, in this specification.

So the `funding_created` message does not mean both parties really deposite money into the channel. The first round communication is just simpley setup a P2SH address, construct funding transaction but unbroadcasted and construct a RSMC. After that, Alice or Bob can broadcast the funding transaction to transfer real Omni assets into the channel.

The following diagram shows the steps we MUST do before any participants broadcast the funding/commitment transactions. BR1a (Breach Remedy) can be created later before the next commitment transaction is contructed.


<p align="center">
  <img width="500" alt="RSMC-C1a-RD1a" src="https://github.com/omnilaboratory/OmniBOLT-spec/blob/master/imgs/RSMC-C1a-RD1a.png">
</p>


1. type: -3400 (btc_funding_created)
2. data:
    * [`32*byte`:`amount`]: total BTC funded by Alice.  
    * [`sha256`:`funding_txid`]: funding transaction id.
    * [`32*byte`:`temporary_channel_id`]: the same as the `temporary_channel_id` in the `open_channel` message.
    * [`u16`:`funding_output_index`]: used in generate the final channel ID.

Alice tells her OBD to notify Bob that she created the funding transaction by payloads packed in this message -3400. 


1. type: -3500 (btc_funding_signed)
2. data:
    * [`channel_id`:`channel_id`]: generated by exclusive-OR of the funding_txid and the funding_output_index from the btc_funding_created message.
    * [`32*byte`:`create_at`]: for example: "2019-09-21T00:14:42.17012+08:00".
    * [`32*byte`:`funder_pubKey`]: the omni address of funder Alice.  
    * [`32*byte`:`fundee_pubKey`]: the omni address of fundee Bob.
    * [`32*byte`:`owner`]: the funder Alice is the owner of the channel.
    * [`32*byte`:`temporary_channel_id`]: the `temporary_channel_id` which will be replaced by channel_id in the following messeges.
    * [`20*byte`:`funding_tx_hash`]: funding transaction id. 
    * [`sha256`:`funding_txid`]: funding transaction id.

Bob tells his OBD to reply Alice that he knows the funding of BTC by message -3500. 

1. type: -34 (asset_funding_created)
2. data:
    * [`32*byte`:`temporary_channel_id`]: the same as the `temporary_channel_id` in the `open_channel` message.
    * [`32*byte`:`funder_pubKey`]: the omni address of funder Alice.
    * [`u64`:`property_id`]: the id of the Omni asset.
    * [`32*byte`:`max_amount`]: the maximum assets in this channel, e.g. 1000 USDT max.
    * [`32*byte`:`amount_a`]: amount of the asset on Alice side.
    * [`sha256`:`funding_txid`]:
    * [`u16`:`funding_output_index`]:
    * [`32*byte`:`to be appended`]:
    
Alice creates the funding transaction by providing her public key, asset id and the amount she wants to deposit in this channel. 
After OBD(OmniBOLT Daemon) receives this message, it asks Bob to sign this transaction.
 
1. type: -35 (asset_funding_signed)
2. data:
    * [`channel_id`:`channel_id`]: generated by exclusive-OR of the funding_txid and the funding_output_index from the funding_created message.
    * [`32*byte`:`funder_pubKey`]: the omni address of funder Alice.
    * [`u64`:`property_id`]: the id of the Omni asset.
    * [`32*byte`:`amount_a`]: amount of the asset on Alice side.
    * [`32*byte`:`fundee_pubKey`]: the omni address of fundee Bob.
    * [`32*byte`:`amount_b`]: amount of the asset on Bob side. Currently obd does not allow fundee to deposit asset as what LND does, because there exists logical risk that fundee's asset may be possiblly locked in channel for ever.
    * [`signature`:`fundee_signature`]: signature of funder Bob.
    * [`64*byte???`:`redeemScript`]: redeem script used to generate P2SH address.
    * [`32*byte`:`p2sh_address`]: hash of redeemScript.
    * [`channel_id`:`channel_id`]: final global channel id generated.
    * [`32*byte`:`to be appended`]:
  
Bob signs, and send `asset_funding_signed` message back to Alice, hence Alice knows the 2-2 P2SH address has been created, but not broadcasted. OBD constructs refund transaction: C1a/RD1a (Revocable Delivery), which pays out from the 2-2 P2SH transaction output:

step 1: Alice constructs a temporary 2-2 multi-sig address using Alice's temporary private key Alice2 and waiting Bob's signature: Alice2 & Bob.

step 2: Alice constructs a promise payment C1a out of Alice & Bob, one output is 60 USDT to `Alice2 & Bob`, and the other output is 40 USDT to Bob.

step 3: RD1a is the first output of C1a, which pays Alice 60 USDT, but with a sequence number preventing immediate payment if Alice cheat.

step 4: Bob signs C1a and RD1a, sends back to Alice.

step 5: OBD constructs refund transaction: C1a/RD1a.
 
The sum of `amount_a` and `amount_b` has to be blow `max_amount` in the `funding_created` message. 
   
   
## The `commitment_tx` and `revoke and acknowledge commitment transaction` Message

The two messages describe a payment inside a channel created by Alice and Bob, upon which HTLC makes it possible for quick payment between any two peers, who do not has a channel yet. We introduce HTLC and corresponding messages in the next chapter.  

### diagram and messages
```
    +-------+                                 +-------+
    |       |--(1)---- commitment_tx  ------->|       |
    |       |<-(2)-- commitment_tx_signed ----|       |
    |   A   |          channel_A_B            |   B   |    
    |       |   construct BR1a, C2a and RD2a  |       | 
    |       |                                 |       |
    |       |--(3)-- Alice2's private key --->|       |
    +-------+                                 +-------+
   
```
     
![RSMC](https://github.com/omnilaboratory/OmniBOLT-spec/blob/master/imgs/RSMC-diagram.png "RSMC")


1. type: -351 (commitment_tx)
2. data:
    * [`32*byte`:`channel_id`]: the global channel id.
    * [`u64`:`property_id`]: the id of the Omni asset. 
    * [`32*byte`:`amount`]: amount of the payment.
    * [`32*byte`:`encrpted_Alice2's private key`]: private key of Alice2, encrypted by Bob's public key.
    * [`32*byte`:`to be appended`]:

** private key of Alice2 MUST be encrypted using Bob's public key, so that Bob can decrypt it when recieves.**

Alice pays Bob `amount` of omni asset by sending `commitment_tx` and , after OBD receieves, construct BR1a(Breach Remedy) and send to Bob. Bob checks the Alice2's signature in BR1a to verify if the private key is correct. If it is, Bob signs C2a/RD2a.

 
1. type: -352 (Revoke and Acknowledge Commitment Transaction)
2. data:
    * [`32*byte`:`channel_id`]: the global channel id.
    * [`u64`:`property_id`]: the id of the Omni asset. 
    * [`32*byte`:`amount`]: amount of the payment.
    * [`signature`:`receiver_signature`]: signature of Bob.
    * [`32*byte`:`to be appended`]:

### cheat and punishment

After Bob signs, OBD constructs C2a and RD2a. Simultaneously, Alice send her temporary private key Alice2 to Bob. If she cheats by broadcasting C1a, Bob will immedialtly get 60 USDT in the channel. There has to be a daeman process that monitors Alice's behaviar. If it detects that Alice broadcasts C1a, it has to notify Bob to broadcast the punishment transaction BR1a using Alice2's private key. If Bob does not broadcast BR1a before the sequence number expires, Alice will success in cheating, and get the 60 USDT.


### balance and transaction history

1. type: -353 (get_balance_request)
2. data:
    * [`32*byte`:`channel_id`]: the global channel id.
    * [`32*byte`:`p2sh_address`]: the p2sh address generated in `funding_signed` message.
    * [`32*byte`:`who`](**Deprecated**): the channel owner, Alice or Bob, can query the balance.
    * [`signature`:`signature`]: the signature of Alice or Bob.


1. type: -354 (get_balance_respond)
2. data:
    * [`32*byte`:`channel_id`]: the global channel id.
    * [`u64`:`property_id`]: the asset id generated by Omnilayer protocol.
    * [`32*byte`:`name`]: the name of the asset.
    * [`float64`:`balance`]: balance in this channel.
    * [`unsigned_64byte_integer`:`reserved`]: currently not in use.
    * [`unsigned_64byte_integer`:`frozen`]: currently not in use.

 
## The `close_channel` Message 
 
**Rationale**
 
This message indicates how to withdraw money from a channel, by broadcasting a `Cna`, which is the latest commitment transaction in this channel. It comprises the following steps:

1. Allice raises a request, to withdraw her money in P2SH, with her proof of her balance.  
2. Alice waits OBD to approval:  
2.1 if they are correct, Alice raises a transaction paying from S2SH to Alice's omni address.  
2.2 if they are wrong/incorrect, OBD rejects the request and notify Bob.  


Before closing a channel, all HTLCs pending in this channel shall be removed, after which close_channel can be successfully executed.

1. type: -38 (close_channel)  
2. data:
    * [`channel_id`:channel_id]
    * [`u16`:`len`]
    * [`len`*`byte:scriptpubkey`]
    * [`signature`:`signature`]: the signature of Alice or Bob.

 
 
